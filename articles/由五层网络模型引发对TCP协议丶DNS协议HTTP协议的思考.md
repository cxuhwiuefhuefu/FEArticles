> 文章首发于我的[GitHub博客](https://github.com/cxuhwiuefhuefu/FEArticles)，如果觉得不错，欢迎给个start哈




## 五层网络模型
- 组成
  - 应用层
    - 组成
      - 应用层
      - 表示层 
        - 作用：用来做数据格式化或者加密等操作
      - 会话层  
    - 作用：为应用软件提供了很多服务，构建于协议之上。
    - 应用层协议（类比暗号）
      - 分类   
        - HTTP协议
        - DNS协议（域名解析）
        - FTP协议（文件传输）
        - SMTP协议（邮件传输）
      - 作用：就像是能识别HTTP协议的程序才能解读HTTP协议里传输的数据内容  
  - 传输层
    - 作用：对数据传输连接的建立和管理，在网络的世界闻名称之为传输层。   
    - 传输层协议
      - UDP协议
        - UDP协议是尽最大努力保证数据送到，但是不保证数据一定能够送到。我们经常用到的Ping命令，来测试主机之间是否联通，原理就是UDP协议。这种在送信过程途中把信弄丢了的情况，在网络世界我们称之为：丢包。
      - TCP协议
        - TCP协议是会保证数据的正确性，也会保证数据的顺序性。
  - 网络层
    - 作用：为数据在节点之间传输创建逻辑链路
    - 网络层协议
        - IP协议
          - 这里的每一栋楼房都相当于连接到网络中的一台计算机，每个屋子都相当于计算机上的一个端口，而交通网络就像是计算机世界的网络。
          - 在网络的世界中，我们称之为网络层。在现实世界中我们要找到一个人的住址我们需要的地址和门牌号，地址和门牌号具有一定的格式，这种格式类比到网络世界中就是一种协议，我们称之为网络层协议。
          - 我们在网络世界中通常用IP加端口来定位一个程序的位置，这种方式就是一种网络层协议，我们称之为IP协议。 
  - 数据链路层
    - 作用：为通讯在实体间创建逻辑链路 
    - 数据链路层又分为两个部分或者称为两个子层，一个是地图上显示的路线我们称之为：逻辑链路控制子层。
    - 另一个是现实世界的路线，我们称之为：媒体访问控制子层，这层的缩写大家肯定熟悉--MAC，也就是人们常说的MAC地址。 
  - 物理层
    - 作用：是定义物理设备如何传输数据（光缆丶网线） 
- 过程
  - 五层网络模型在数据运输的过程中，先是从A处的应用层到运输层到网络层到数据链路层到物理层，将数据运送到B处，然后再从B处的物理层到数据链路层到网络层到运输层到运用层。
  - 每层协议本质上就是在外面套一层特殊格式的数据。所以在将数据送到的时候，需要将这一层层的协议拆开，如何才能得到里面的数据。 




## TCP协议
- TCP三次握手
  - 作用：三次握手主要目的是为了确认两台主机都具备收和发的能力
  - 过程
    - 第一次握手
      - 主要传递两个信息，一个是请求建立连接（SYN=1），二是发出一个序列号（seq=n）。
      - 作用：第一次握手让B主机知道A可以发出信息 
    - 第二次握手
      - 这次回复三个信息，以是同意建立连接（SYN=1），二是确认收到了刚才的信息（ack=刚才的seq+1），三是发出自己的序列号（seq=x）。
      - 作用：第二次握手让A知道了B能收到也能发出。
    - 第三次握手 
      - 这次回复三个信息，一是表示现在开始发送（SYN=0），二是成功收到了刚才的信息（ack=刚才的seq+1），三是发出自己的序号（最开始发出序号+1）。
      - 作用：第二次握手让B知道了A能收到也能发出。
- TCP四次挥手
  - 核心在于四个时间点，分别是：发完了，知道发完了，收完了，知道收完了。
  - 过程
    - 第一次挥手
      - A告诉B数据发送完了
    - 第二次挥手
      - B知道A发完了
    - 第三次挥手
      - B告诉A接收完了
    - 第四次挥手
      - A知道B接收完了
- 为什么握手只需要三次而挥手需要四次？
  - 就是因为A告诉B发完了的时候，B还有可能没有接收完信息，所以只能先回复一部分，告诉A已经知道发完了的消息了。当消息完全接收完毕之后，才会告诉A已经接收完了。             
- TCP和UDP区别？
  - 连接方面
    - TCP面向连接的（如打电话要先拨号建立连接）
    - UPD是无法连接的，即发送数据之前不需要建立连接。
  - 安全方面
    - TCP提供可靠的服务，提供TCP连接传送的数据，无差别，不丢失，不重复，且按序到达。
    - UDP尽最大努力交付，即不保证可靠交付。
  - 传输效率的区别
    - TCP传输效率相对较低
    - UDP传输效率较高，适用于对高速传输和实时性有较高的通信和广播通信。
  - 连接对象数量的区别
    - TCP连接只能是点到点丶一对一的。
    - UDP支持一对一丶一对多丶多对一和多对多的交互通信。  
- TCP和IP协议区别
  - TCP：又叫传输控制协议，是一种面向连接的丶端对端的丶可靠的丶基于IP和传输层协议。主要特点是3次握手建立连接，4次挥手断开连接。
  - IP：又叫因特网协议，IP协议位于网络层，IP协议规定了数据传输时的基本单元（数据包）和格式，IP协议还定义了数据包的递交方法和路由选择。
  - 整个网络中的传输流程是：IP层接收由更底层（网络接口例如以太网设备驱动程序）发来的数据包，并把该数据发送到更高层-TCP层，相反，IP层也把从TCP接收来的数据包传送到更低层。
  - TCP和IP的关系是：IP提供基本的数据传送，而高层的TCP对这些数据包做进一步的加工，如提供端口号等等。           



      
## HTTP
- 定义
  - HTTP全称是HyperText Transfer Protocal，即超文本传输协议，是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。
  - HTTP是一个基于TCP/IP通信协议来传输数据
- HTTP工作原理
  - HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向WEB服务器发送所有的请求。
- 特点
  - 支持客户端/服务器模式
  - 简单快速
      - 客户端向服务端请求服务时，只需传送请求方法和路径。请求常用的有GET丶HEAD丶POST。每种方法规定了客户端和服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务的程序规模小，因而通信速度很快。   
  - 灵活
    - HTTP允许传输任意类型的数据类型。
    - 正在传输的类型由Content-Type  (Content-Type是HTTP包用来表示内容类型的标识)加以标记。
  - HTTP是无连接。
    - 无连接的含义是限制每次连接只处理一个请求。
    - 服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。
    - 采用这种方式可以节省传输时间。   
  - HTTP是无状态的
    - HTTP协议是无状态协议。无状态协议是指对于事务处理没有记忆能力。缺少状态意味着如果后续处理前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
    - 另一方面，在服务器不需要先前信息时它的应答就较快。   

- 组成
  - HTTP之请求消息Request 
    - 请求行
      - 用来说明请求类型，要访问的资源以及所用到我的HTTP版本 
    - 请求头部
      - 说明服务器要使用的附加消息
    - 空行
      - 请求头部后面的空行是必须的
    - 请求数据
      - 可以任意添加其他数据  
  - HTTP之响应消息Response
    - 状态行
      - 由HTTP版本协议号丶状态码丶消息状态三个部分组成 
    - 消息报文
      - 用来说明客户端要使用的一些附加信息 
    - 空行
      - 消息报文后面的空行是必须的 
    - 响应正文  
      - 服务端返回给客户端的文本信息


- HTTP状态码
  - 定义：
    - 用来描述返回的结果，记住状态码，我们可以知道的处理了请求还是处理了错误，状态码响应类别一共有五种。比如200，数字中的第一位指响应类别，后两位为分类。
  - 五种类型分别是
    1XX（信息性状态码）| 接受的请求正在处理，不常见
    -|:-
    2XX（成功状态码）  | 请求正常处理完毕   
    3XX（重定向状态码）| 需要进行附加操作已完成请求
    4XX（客户端错误码）| 服务器无法请求类别
    5XX（服务端错误状态码）| 服务器处理请求出错
  - 常用状态码
    - 2XX 成功
      200 | 客户端请求在服务端正常处理
      -|:- 
      204 | 请求成功但是没有资源返回
      206 | 表示了客户端进行了范围请求，而服务器成功执行了这部分的GET请求，首部字段中有content-rage意思是客户端进行了范围请求
    - 3XX 重定向
      301 | 永久性重定向
      -|:-
      302 | 临时性重定向
      303 | 请求的资源存在另一个URI，应使用GET方法定向获取请求资源
      304 | 当浏览器多次访问同一个资源的时候，如果第一次请求的结果还在缓存，还没有过期，那么在此访问这个资源的时候，为了减少网络传输的消耗，如果这个资源还没有被修改过，则可以让浏览器继续使用之前缓存的内容，这样就不用将资源再发送一遍了，所以减少了很多网络开销。
      307 | 临时重定向         
    - 4XX 客户端错误码
      400 | 请求报文存在语法错误    
      -|:-
      401 | 发送的请求需要通过HTTP认证的认证信息，如果之前请求过一次，则表示用户认证失败。
      403 | 不允许访问该资源
      404 | 服务器上没有该资源
    - 5XX 服务器错误
      500 | 服务器端在执行请求时发生错误
      -|:-
      503 | 服务器暂时处于超负荷或正在停机维护，无法处理请求。        
- HTTP请求方式
  get | 从服务器取出资源
  -|:-
  post | 在服务器新建一个资源
  put | 在服务器更新资源
  delete | 从服务器删除资源    
  - GET和POST真正区别
    - 在本质上，GET请求和POST请求都能拉取数据。
    - 我们常说的HTTP协议实际上是基于RFC规范的，实际上GET和POST请求的语法是完全相同的，但是在RFC规范中，给GET请求和POST请求规定了语法，规定GET用来获取信息，POST用来发送信息。
    - 如果什么前提都没有，也就是不用任何规范的话，我们只考虑语法来说，这两个方式是没有任何区别的，只是名字不一样。
    - 如果是基于RFC规范的，那么问题就又来了。是基于RFC理论  的，还是基于具体的实现的。
      - 如果是基于RFC理论的，我们称这个为Specification。那么GET和POST是具有相同的语法，但是不具备相同的语义，GET方式用作获取信息，POST方式用作发送信息。
      - 如果是基于RFC的具体实现的，我们称之为implementation。其实要区分是具体的哪一种实现，我们通常默认指的是浏览器实现的RFC。当然不止浏览器，我们任何人都可以设计一种HTTP协议的接口，使用RFC规范，当然这些是我们不用考虑的，因为并不通用。     
        - GET的数据在URL中对所有人都是可见的。POST的数据不会显示在URL中。
        - GET对数据长度有限制，当发送数据时，GET方法向URL添加数据；URL的长度是受限制的（URL是最大长度是2048个字符）。POST无限制。
        - GET可收藏为书签，POST不可收藏为书签。
        - GET后退按钮/刷新无影响，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）
        - GET编码类型aplication/x-www-form-url，POST编码类型encodeapplication/x-www-form-urlencoded或multipart/form-data。为二进制数据使用多重编码。
        - GET历史参数会保留在浏览器历史中。POST参数不会保存在浏览器历史中。
        - GET只允许SCII字符。POST没有限制。也允许二进制数据。
        - 与POST相比，GET的安全性比较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息的时候绝不要要善于GET！POST比GET更安全，因为参数不会被保存在浏览器历史或web服务器日志中。
        - GET请求只会有一次TCP连接，而POST请求会有两次TCP连接。
          - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）。
          - 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
          - 在网络环境好的情况下，发一次包的时候和发两次包的时候差别基本可以无视。而在网络差的环境的情况下，两次包的TCP在验证数据包的完整性上，有非常大的优点。  
          - 并不是所有的浏览器在POST中发送两次包，Firefox只发送一次。
- HTTP缓存机制
  - 浏览器加载一个页面的简单流程： 
    - 浏览器先根据这个资源的HTTP头信息来判断是否命中强缓存。如果命中则直接加载缓存中资源，则不会将请求发送到服务器。
    - 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存中加载资源。
    - 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。 
  - 强缓存
    - 命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到的HTTP的返回码是200，但是在Size列会显示为（from cache）。
    - 强缓存是利用HTTP的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。     
  - 协商缓存 
    - 若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据HTTP头信息中的Last-Modify/If-Modify-Since或If-None-Match来判断是否命中协商缓存。如果命中，则HTTP返回码为304，浏览器从缓存中加载资源。
  
  
  - cache-control
    - max-age
      - 作用：缓存的资源，超过一定时间就不要了，就要重新请求。
      - max-age后面通常跟着一串数字，表示缓存的秒数。 
    - max-stale
      - 作用：过期一点的时间无所谓。
      - max-stale后面也跟着秒数，表示过期多长时间的东西也可以继续使用。   
      - max-stale多数的时候会跟着max-age一起使用
    - no-cache
      - 作用：不会直接使用缓存，而是每次使用资源之前，都要先向服务器询问一下这个资源还能不能用，如果能用就继续用，如果不能用就重新请求。
    - no-store
      - 作用：每次都要向服务器请求资源。
    - public
      - 作用：表示任何地方都可以缓存资源。
    - private
      - 作用：只允许客户端进行缓存，代理服务器不能缓存这个资源。
    - must-revalidation
      - max-age和must-revalidation都是本地过期之后去服务端重新请求资源。
      - 但是区别在于，如果使用max-age，那么如果资源没过期，新开的窗口也会使用这个资源。如果是must-revalidation，每次新打开窗口，都会向服务器去请求资源。       
    - no-transform
      - 作用：通常当传输图片或资源时，有时代理服务器为了有更好的性能，会对图片或者资源进行压缩，或者格式的转换。但是如果在响应头中带有这个字段，就表示不允许在传输的中途对资源做任何修改。     
  - 总结：浏览器第一次请求，无缓存，向WEB服务器请求，请求响应，协商缓存，呈现。
  - 浏览器再次请求时
    ```objc 
    浏览器请求
        |
      有缓存      
        |
      是否过期？是--> Etag? --> 是 --> 向Web服务器请求带If-None-Match           -->|
        |             |                                                          |
        |             否                                                         |
       否             |                                                          |
        |          last-Modified --> 是 --> 向Web服务器请求带If-Modified-Since  -->| 
        |             |                                                      服务器决策
     从缓存读取        否                                                         |
        |             |                                                     200 or  304
        |        向Web服务器请求                                               |       |
        |             |                                                       |       |
                请求响应，缓存协商           <---- 200            <--          200      |
                      |                                                            从缓存读取
                      |                                                                |
          -->        呈现                                      <--                     |
    ``` 
- HTTP和HTTPS区别  
  - HTTPS还是通过了HTTP来传输信息，但是信息通过TLS协议进行了加密。
  - 在TLS中使用两种加密技术。
    - 对称加密
      - 对称加密就是两边都拥有相同的秘钥，两边都知道如何将密文加密。
      - 这种加密方式固定很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式进行传递的话，一旦秘钥被截获就没有加密的意义的。 
    - 非对称加密 
      - 有公钥私钥之分，公钥所有人都知道，可以将数据加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。
      - 这种加密方式就可以完美解决对称加密存在的问题。加速两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。 
      - 简单流程：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，如果通过公钥加密并发送给服务端，服务端收到密文以后通过私钥解密出正确的秘钥，这个时候两端都知道秘钥是什么了。
    - TLS握手流程
      - 客户端发送一个随机值以及需要的协议和加密方式。
      - 服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需要的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端需要说明）。
      - 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书。
      - 服务端收到加密的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成秘钥，接下来的通信就可以通过该密钥来加密解密。 



- HTTP版本
- HTTP2.0的特点
  - 多路复用/二进制协议
    - HTTP1.1版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧“：头信息和数据帧。
    - 二进制协议的一个好处是，可以定义额外的帧。HTTP/2定义了近十钟帧，为将来的高级应用打好了基础。例如  使用文本实现这种功能，解析数据会变得非常麻烦，二进制解析则方便得多。
  - 多工
    - HTTP/2复用TCP连接，在一个连接里，客户端和浏览器都可以使用同时发送给多个请求或回应，而且不用按照顺序一一回应，这样就避免了“队头堵塞”。
    - 举例来说，在一个TCP连接里面，服务器同时收到A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分，接着回应B请求，完成后，再发送A请求剩下的部分。
    - 这样双向丶实时的通信，就叫做多工。
  - 数据流
    - 因为HTTP/2的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。
    - HTTP/2将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪一个数据流。另一个还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数
    - 数据流发送到一半的时候，客户端和服务器都可以发送信号，取消这个数据流。1.1版本取消数据流的唯一方法，就是关闭TCP连接。也就是说，HTTP/2可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。
    - 客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。
  - 头部信息压缩
    - HTTP版本不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如`cookie`和`User Agent`，一模一样的内容，每次请求都必须附带，这会浪费很多宽带，也影响速度。
    - HTTP2对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头部信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
  - 服务器推送
    - HTTP2允许服务器未经请求，主动向客户端发送资源，这就叫做服务器推送
    - 常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须受到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能再请求静态资源，所以就主动把这些静态资源随着网页预期发给客户端。




- URI和URL区别



## （DNS协议）域名解析过程
- 定义：从我们输入域名开始直到我们获得要访问的ip地址的过程
- 过程
  - 当我们输入一个URL的时候，浏览器会先从本地的缓存中看，有没有这个域名对应。
  - 当要访问的URL没有命中本地的浏览器缓存时，就要查看计算机本地的HOST指向，有没有相关的记录。计算机本地的HOST是一个文件，记录着域名和IP的映射关系。
  - 当浏览器缓存和计算机HOST都没有命中的时候，就要求助于本地的DNS解析服务器了。本地的DNS解析服务器我们称之为LDNS。这些服务器距离我们比较近，可能在每个城市都会有。
    - 每个城市的DNS也不可能记住全世界所有的网址，所有的LDNS也有可能找不到相应的域名对应的IP。  
  - 当本地的DNS解析找不到的时候，就会求助更权威的机构。也就是gTLD Server。gTLD Server全称是Generic top-level domain Server，通用顶级域Server。
    - 我们常见的域名后缀有.com的，有.net的，有.org的等等很多。每个顶级域名都有一个记录者所有注册过相应域名的记录。比如.com域名的服务器就会记录着全部注册过的.com的域名。
    - 每个域名后缀的顶级域名也不可能只有一台，毕竟一台机器无法承受这么大的访问量，可能有好多台。
    - 但是LDNS只会访问其中的一台，当被访问的状态gTLD Server收到了这个域名之后，会告诉LDNS你应该去询问哪台机器，然后LDNS再去相应的机器去询问这个域名对应的IP。 
    - 当LDNS从gTLD获取到了域名对应的IP之后就会把这个信息返回到发出请求的计算机，然后LDNS会在本地进行缓存，相应的浏览器也会对这个域名和IP进行缓存，以保证下次再有访问这个域名的时可以很快的响应。   




参考链接

[https://www.ruanyifeng.com/blog/2016/08/http.html](https://www.ruanyifeng.com/blog/2016/08/http.html)





#### 如果你看完觉得这篇文章不错，帮我两件小事
- 关注公众号<text style="color: blue; font-weight: bold;">【前端应届生】</text>，持续为你推送精彩文章。
  
  <img style="width: 200px" src="https://imgkr.cn-bj.ufileos.com/51a2dad3-ae5b-4f66-9717-f0a36e4c68a7.png">
- 加我备注<text style="color: blue" style="color: blue;">【加群】</text>拉你进超级前端交流群，和各大厂的同学一起交流学习，共同进步。
  
  <img style="width: 200px" src="https://imgkr.cn-bj.ufileos.com/36e0b949-54df-4698-9ca2-d7e39ed0e2c0.jpg">

